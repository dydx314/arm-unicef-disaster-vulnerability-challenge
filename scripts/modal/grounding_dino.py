from modal_store import zindi_image, zindi_volumes, REMOTE_DIR
from modal import App

import utils
import pandas as pd

app = App()

with zindi_image.imports():
    import cv2
    import matplotlib.pyplot as plt
    import requests
    import torch
    from PIL import Image
    from transformers import AutoModelForZeroShotObjectDetection, AutoProcessor


@app.function(image=zindi_image, volumes=zindi_volumes, timeout=7200, gpu="any")
def run_detection(img_ids, text):
    img_dir = f"{REMOTE_DIR}/data/Images"
    device = "cuda"
    model_id = "IDEA-Research/grounding-dino-tiny"

    processor = AutoProcessor.from_pretrained(model_id)
    model = AutoModelForZeroShotObjectDetection.from_pretrained(model_id).to(device)

    results = {}
    for img_id in img_ids:
        image = Image.open(f"{img_dir}/{img_id}.tif")
        inputs = processor(images=image, text=text, return_tensors="pt").to(device)
        with torch.no_grad():
            outputs = model(**inputs)

        result = processor.post_process_grounded_object_detection(
            outputs,
            inputs.input_ids,
            box_threshold=0.4,
            text_threshold=0.3,
            target_sizes=[image.size[::-1]],
        )[0]
        results[img_id] = {
            "scores": result["scores"].tolist(),
            "labels": result["labels"],
            "boxes": result["boxes"].tolist(),
        }
    return results


def evaluate_10():
    train_df = pd.read_csv("data/train.csv")
    img_ids = train_df[:10].image_id.values
    # text = "houses with tin roof."
    text = "metal-roof houses."

    results = run_detection.remote(img_ids, text)

    for img_id in img_ids:
        img_path_local = f"../../Downloads/Images/{img_id}.tif"
        image = Image.open(img_path_local)
        result_dict = results[img_id]
        utils.plot_results(
            image,
            text,
            result_dict["scores"],
            result_dict["labels"],
            result_dict["boxes"],
            show_plot=False,
            save_path=f"results/grounding_dino/tin/{img_id}.tif",
        )

    # text = "houses with grass-thatched roof."
    text = "grass-roof houses."

    results = run_detection.remote(img_ids, text)

    for img_id in img_ids:
        img_path_local = f"../../Downloads/Images/{img_id}.tif"
        image = Image.open(img_path_local)
        result_dict = results[img_id]
        utils.plot_results(
            image,
            text,
            result_dict["scores"],
            result_dict["labels"],
            result_dict["boxes"],
            show_plot=False,
            save_path=f"results/grounding_dino/thatched/{img_id}.tif",
        )

        # bboxes = train_df[train_df.image_id == img_id]["bbox"].values
        # labels = train_df[train_df.image_id == img_id]["category_id"].values
        # utils.plot_ground_truth(
        #     img_path_local,
        #     bboxes,
        #     labels,
        #     show_plot=False,
        #     save_path=f"data/img_bbox/{img_id}.tif",
        # )


def plot(img_ids, text, results):
    for img_id in img_ids:
        img_path_local = f"../../Downloads/Images/{img_id}.tif"
        image = Image.open(img_path_local)
        result_dict = results[img_id]
        utils.plot_results(
            image,
            text,
            result_dict["scores"],
            result_dict["labels"],
            result_dict["boxes"],
            show_plot=False,
        )


def evaluate_test():
    test_df = pd.read_csv("data/final/Test.csv")
    img_ids = test_df.image_id.values
    text = "metal-roof houses."
    results_2 = run_detection.remote(img_ids, text)

    # text = "grass-roof houses."
    # results_3 = run_detection.remote(img_ids, text)

    submission_tuples = []
    for img_id in img_ids:
        submission_tuples.extend(
            [
                (f"{img_id}_1", 0),
                (f"{img_id}_2", len(results_2[img_id]["labels"])),
                (f"{img_id}_3", 0),
            ]
        )
    submission_df = pd.DataFrame(submission_tuples, columns=["image_id", "Target"])
    submission_df.to_csv("results/grounding_dino/test_pred.csv", index=False)


def evaluate_val(limit=None):
    val_df = pd.read_csv("data/val.csv")
    if limit:
        val_df = val_df[:limit]
    img_ids = val_df.image_id.values
    text = "metal-roof houses."
    results_2 = run_detection.remote(img_ids, text)

    # text = "grass-roof houses."
    # results_3 = run_detection.remote(img_ids, text)

    val_pred_tuples = []
    for img_id in img_ids:
        val_pred_tuples.extend(
            [
                (f"{img_id}_1", 0),
                (f"{img_id}_2", len(results_2[img_id]["labels"])),
                (f"{img_id}_3", 0),
            ]
        )
    val_pred_df = pd.DataFrame(val_pred_tuples, columns=["image_id", "Target"])
    val_pred_df.to_csv("results/grounding_dino/val_pred.csv", index=False)

    # MAE
    val_target_df = pd.read_csv("data/val_target.csv")
    print("MAE is:", utils.mean_absolute_error(val_pred_df, val_target_df))


@app.local_entrypoint()
def main():
    # evaluate_10()
    #evaluate_val()
    evaluate_test()
