#this resizes all images in train and test
from PIL import Image
import pandas as pd
import numpy as np
import re
import os
import yaml
import shutil
from tqdm import tqdm

image_width = 640
image_height = 640
train_destination_folder = "./data/train/images"
val_destination_folder = "./data/val/images"
copy_from_folder = "./data/Images"

def decode_points(ddbox: str) -> list:
    points = [np.float32(point) for point in re.findall(r'\d+\.\d+', ddbox)]
    return points

def create_data_folder(destination_folder, df):
    if not os.path.exists(destination_folder):
        os.makedirs(destination_folder)
        
    unique_images = df['image_id'].unique()
    
    for img in unique_images:
        img_path = os.path.join(copy_from_folder, img + '.tif')
        if os.path.exists(img_path):
            shutil.copy(img_path, destination_folder)

#W and H are the width and height of the image
def convert_bbox_to_string(bbox, W, H):
    box = decode_points(bbox)
    w = box[2]
    h = box[3]
    xc = box[0] + int(np.round(w/2))
    yc = box[1] + int(np.round(h/2))
    box = [xc/W, yc/H, w/W, h/H]
    box = [f"{i:.4g}" for i in box]
    return " ".join(box)

def create_label_folder(label_dir, dataframe):
    if not os.path.exists(label_dir):
        os.makedirs(label_dir)
        
    unique_images = dataframe['image_id'].unique()
    
    for i,img in zip(tqdm(range(len(unique_images))), unique_images):
        W, H = Image.open(f"{copy_from_folder}/{img}.tif").size
        print("width, height", W, H)
        df = dataframe[dataframe['image_id'] == img]
        output_lines = []
        for index, row in df.iterrows():
            category_id = int(row['category_id']) - 1

            bbox_string = convert_bbox_to_string(row['bbox'], W, H)
            output_lines.append(f'{category_id} {bbox_string}')

        with open(f"{label_dir}/{img}.txt", 'w') as f:
            for line in output_lines:
                f.write(line + '\n')

# #step 1 - split train into train and val and copy images
# train = pd.read_csv("./data/Train.csv")
# train.dropna(inplace=True)
# test = pd.read_csv("./data/Test.csv")
# test.dropna(inplace=True)
# unique_images = train['image_id'].unique()
# val_size = int(len(unique_images) * 0.2)
# train_imgs = unique_images[:(len(unique_images) - val_size)]
# val_imgs = unique_images[-val_size:]
# train_idx = np.isin(train['image_id'].values, train_imgs)
# val_idx = np.isin(train['image_id'].values, val_imgs)
# train_df = train.iloc[train_idx]
# val_df = train.iloc[val_idx]


# #step 2 - copy all labels from the .csv and create repos with COCO format. ensure the bounding boxes are in YOLO format
# #note that because the bb are in yolo format, the bb's don't need to be updated if the images are resized
# create_data_folder(train_destination_folder, train_df)
# create_data_folder(val_destination_folder, val_df)
# create_label_folder("./data/train/labels", train_df)
# create_label_folder("./data/val/labels", val_df)
# num_classes = 3
# names = ["Thatch", "Tin", "Other"]

# train_dest_dir = "./train"
# val_dest_dir = "./val"

# dict_file = {
#     'train': train_dest_dir,
#     'val' : val_dest_dir,
#     'nc': num_classes,
#     'names': names
#     }

# with open("./data/data.yaml", 'w+') as file:
#     yaml.dump(dict_file, file)


# #create a test folder with all of the resized test images
# create_data_folder("./data/test/images", test)


# Define the input directory containing the .tif images
input_directories = ['./data/train/images', './data/val/images', './data/test/images']  


# Iterate over all files in the input directory
for input_directory in input_directories:
    for filename in os.listdir(input_directory):
        if filename.endswith(".tif"):
            # Construct the full file path
            file_path = os.path.join(input_directory, filename)
            
            # Open the image file
            with Image.open(file_path) as img:
                # Resize the image to things divisible by 32 (good for convnets)
                img_resized = img.resize((image_width, image_height), Image.LANCZOS)
            
                # Save the resized image to the output directory
                img_resized.save(file_path)
                
            print(f"Resized and saved: {file_path}")

print("All images have been resized.")





