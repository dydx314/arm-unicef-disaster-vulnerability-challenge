#Script to split data into train and val datasets and then clean everything so that its the same size
#this is updated to do contrast stretching and larger -resizing for Faster RCNN model

#this resizes all images in train and test
from PIL import Image
import pandas as pd
import numpy as np
import re
import os
import yaml
import shutil
from tqdm import tqdm
import random

image_width = 1000
image_height = 1000
train_destination_folder = "./data/train/images"
val_destination_folder = "./data/val/images"
test_destination_folder = "./data/test/images"
copy_from_folder = "./data/Images"

def decode_points(ddbox: str) -> list:
    points = [np.float32(point) for point in re.findall(r'\d+\.\d+', ddbox)]
    return points

def create_data_folder(destination_folder, df):
    if not os.path.exists(destination_folder):
        os.makedirs(destination_folder)
        
    unique_images = df['image_id'].unique()
    
    for img in unique_images:
        img_path = os.path.join(copy_from_folder, img + '.tif')
        if os.path.exists(img_path):
            shutil.copy(img_path, destination_folder)

#W and H are the width and height of the image
def convert_bbox_to_string(bbox, W, H):
    box = decode_points(bbox)
    w = box[2]
    h = box[3]
    xc = box[0] + int(np.round(w/2))
    yc = box[1] + int(np.round(h/2))
    box = [xc/W, yc/H, w/W, h/H]
    box = [f"{i:.4g}" for i in box]
    return " ".join(box)

def create_label_folder(label_dir, dataframe):
    if not os.path.exists(label_dir):
        os.makedirs(label_dir)
        
    unique_images = dataframe['image_id'].unique()
    
    for i,img in zip(tqdm(range(len(unique_images))), unique_images):
        W, H = Image.open(f"{copy_from_folder}/{img}.tif").size
        print("width, height", W, H)
        df = dataframe[dataframe['image_id'] == img]
        output_lines = []
        for index, row in df.iterrows():
            category_id = int(row['category_id']) - 1

            bbox_string = convert_bbox_to_string(row['bbox'], W, H)
            output_lines.append(f'{category_id} {bbox_string}')

        with open(f"{label_dir}/{img}.txt", 'w') as f:
            for line in output_lines:
                f.write(line + '\n')

# Function to calculate percentiles
def calculate_percentiles(images, percentiles):
    all_pixels = {channel: [] for channel in range(3)}
    
    #perform the following for a random selection of 100 images
    selected_images = random.sample(images, 100)

    for img in selected_images:
        pixels = np.array(img)
        for channel in range(3):
            all_pixels[channel].extend(pixels[:, :, channel].flatten())
    
    result = {}
    for channel in range(3):
        result[channel] = np.percentile(all_pixels[channel], percentiles)
    
    return result

# Function to apply contrast stretching
def contrast_stretching(image, r0, r1, g0, g1, b0, b1):
    pixels = np.array(image).astype(np.float32)
    
    # Apply the contrast stretching transformation
    pixels[:, :, 0] = np.clip(255 * (pixels[:, :, 0] - r0) / (r1 - r0), 0, 255)
    pixels[:, :, 1] = np.clip(255 * (pixels[:, :, 1] - g0) / (g1 - g0), 0, 255)
    pixels[:, :, 2] = np.clip(255 * (pixels[:, :, 2] - b0) / (b1 - b0), 0, 255)
    
    return Image.fromarray(pixels.astype(np.uint8))

#step 1 - split train into train and val and copy images
train = pd.read_csv("./data/Train.csv")
train.dropna(inplace=True)
test_df = pd.read_csv("./data/Test.csv")
test_df.dropna(inplace=True)

unique_images = train['image_id'].unique()
val_size = int(len(unique_images) * 0.2)

train_imgs = unique_images[:(len(unique_images) - val_size)]
val_imgs = unique_images[-val_size:]
train_idx = np.isin(train['image_id'].values, train_imgs)
val_idx = np.isin(train['image_id'].values, val_imgs)
train_df = train.iloc[train_idx]
val_df = train.iloc[val_idx]


#step 2 - copy all labels from the .csv and create repos with COCO format. ensure the bounding boxes are in YOLO format
#note that because the bb are in yolo format, the bb's don't need to be updated if the images are resized
create_data_folder(train_destination_folder, train_df)
create_data_folder(val_destination_folder, val_df)
create_data_folder(test_destination_folder, test_df)

create_label_folder("./data/train/labels", train_df)
create_label_folder("./data/val/labels", val_df)
num_classes = 3
names = ["Thatch", "Tin", "Other"]

train_dest_dir = "./train"
val_dest_dir = "./val"

dict_file = {
    'train': train_dest_dir,
    'val' : val_dest_dir,
    'nc': num_classes,
    'names': names
    }

# with open("./data/data.yaml", 'w+') as file:
#     yaml.dump(dict_file, file)




# Define the input directory containing the .tif images
input_directories = ['./data/train/images', './data/val/images', './data/test/images']  


# Step 1: Gather 500 random images and calculate percentiles
images = []
for input_directory in input_directories:
    i = 500/3
    for filename in os.listdir(input_directory):
        i -= 1
        if i < 0:
            break
        if filename.endswith(".tif"):
            file_path = os.path.join(input_directory, filename)
            with Image.open(file_path) as img:
                images.append(img.copy())

# Calculate 3rd and 97th percentiles for each channel
percentiles = (3, 97)
vals = calculate_percentiles(images, percentiles)
r0, r1 = vals[0]
g0, g1 = vals[1]
b0, b1 = vals[2]
print(f"3rd and 97th percentiles for each channel: {vals}")

# Step 2: Resize and apply contrast stretching to each image
for input_directory in input_directories:
    i = 0
    for filename in os.listdir(input_directory):
        i += 1
        if i % 100 == 0:
            print(f"Processed {i} images")
        if filename.endswith(".tif"):
            file_path = os.path.join(input_directory, filename)
            
            # Open the image file
            with Image.open(file_path) as img:
                # Resize the image
                img_resized = img.resize((image_width, image_height), Image.LANCZOS)
                
                # Apply contrast stretching
                img_stretched = contrast_stretching(img_resized, r0, r1, g0, g1, b0, b1)
                
                # Save the resized and contrast-stretched image to the output directory
                img_stretched.save(file_path)
                
            #print(f"Resized, contrast-stretched, and saved: {file_path}")

print("All images have been resized and contrast-stretched.")


